function [Y] = processAHVregression_values2(cfg_in, X)
% 10/2021. JJS.
% Inputs:   X  -  structre with fields X.  ...    (generated by findAHVslopesFromTuningCurves2.m)
% this version corrects the code so that for asymmetric cells, only one side needs to be significant (they just can't be sig in opposing directions -- symmetric)
%

%                       rsqAll:     [1×n double]     Rsq statistic for each neuron, fit with a single line
%                       pAll:       [1×n double]     p-values for each neuron, fit with a single line
%                       coeffsAll:  [n×2 double]     1st row = slope (Beta value); 2nd row = y-intercept. Single line fit
%                       rsqPos:     [1×n double]     Rsq for positive part of tuning curve (above zero deg/sec)
%                       pPos:       [1×n double]     p-values for positive part of tuning curve
%                       coeffsPos:  [n×2 double]     coeffs for positive part of tuning curve
%                       rsqNeg:     [1×n double]     Rsq for negative part of tuning curve
%                       pNeg:       [1×n double]     p-values for negative part of tuning curve
%                       coeffsNeg:  [n×1 double]     coeffs for negative part of tuning curve
% fd = FindFiles('*keys.m');
numCells = length(X. pAll);
cfg_def.Bonferroni = 0;
cfg_def.doPlot = 1;
cfg_def.pearson = .5;  % requirement for pearsons correlation to be a certain value. Such as > .5. For no requirement, set to 0. Note use of abs() below. 
cfg = ProcessConfig2(cfg_def, cfg_in);

if cfg.Bonferroni == 0
    threshold = .05;
else
    threshold = .05/numCells;
end
Y.indexP = X.pPos < threshold & X.pNeg < threshold;  % index of cells with significant p-values for both components

Y.indexL = X.pNeg < threshold;   % LEFT side of the plot is significant. Could be \ / 
Y.indexR = X.pPos < threshold;   % RIGHT side of the plot is significant. Could be \ or / 

%% Determine which cells are A-SYMMETRIC (and significant)

% Right MESA.        -AHV side is positive slope. Right side is a flat (not sig). 
RM =  X.bNeg > 0 & X.pNeg < threshold & X.pPos >= threshold & abs(X.Rneg) >= cfg.pearson; fRM = find(RM); 
% Left MESA          +AHV side is negative slope. Left side is a flat (not sig). 
LM = X.bPos < 0 & X.pPos < threshold & X.pNeg >= threshold & abs(X.Rpos) >= cfg.pearson; fLM = find(LM);
% Uphill Slope.      +AHV side is psoitive slope. Right side is flat (not sig).  
US = X.bPos > 0 & X.pPos < threshold & X.pNeg >= threshold & abs(X.Rpos) >= cfg.pearson;  fUS = find(US);
% Downhill Slope.    -AHV side is negative sleop. Right side is flat (not sig). 
DS = X.bNeg < 0 & X.pNeg < threshold & X.pPos >= threshold & abs(X.Rneg) >= cfg.pearson; fDS = find(DS);
% Pos Line.          Both halves have positive slope. 
PL = X.bNeg > 0 & X.bPos > 0 & X.pNeg < threshold & X.pPos < threshold & abs(X.Rall) >= cfg.pearson; fPL = find(PL);  % maybe change this to X.pAll < threshold 
% Neg Line.          Both halves have negative slope.
NL = X.bNeg < 0 & X.bPos < 0 & X.pNeg < threshold & X.pPos < threshold & abs(X.Rall) >= cfg.pearson; fNL = find(NL);  % maybe change this to X.pAll < threshold 
%% Determine which cells are SYMMETRUC (and significant) 
% V - Shape.      
V = X.bNeg < 0 & X.bPos > 0 & X.pNeg < threshold & X.pPos < threshold & abs(X.Rneg) > cfg.pearson & abs(X.Rpos) > cfg.pearson; fV = find(V);
% Circumflex 
C = X.bNeg > 0 & X.bPos < 0 & X.pNeg < threshold & X.pPos < threshold & abs(X.Rneg) > cfg.pearson & abs(X.Rpos) > cfg.pearson; fC = find(C); 
%% Not significant 
% Flat. A particular kind of not significant.  
F = X.pNeg >=   threshold & X.pPos >= threshold;   fF = find(F); 
% N.S. by process of exclusion. 
Y.ns =  ~RM & ~LM & ~US & ~DS & ~PL & ~NL & ~V & ~C;   
Y.S  =  RM | LM | US | DS | PL | NL | V | C;

sumSig = sum(RM) + sum(LM) + sum(US) + sum(DS) + sum(PL) + sum(NL) + sum(V) + sum(C);  Y.percentSig = sumSig/numCells; 
% sumNonSig = sum(F); Y.percentNonSig = sum(F)/numCells; 
sumNonSig = sum(Y.ns); Y.percentNonSig = sumNonSig/numCells; 

assert(sumSig + sumNonSig == numCells); 

CCW = sum(RM) + sum(US) + sum(PL); 
CW = sum(LM) + sum(DS) + sum(NL); 

if cfg.doPlot ==1
    Pall = [sumNonSig CW CCW sum(V) sum(C)];  
    labels = {'Not sig.', 'Asymmetric CW', 'Asymmetric CCW', 'Symmetric, V shape', 'Symmetric, Hat Shape'}; 
    pie(Pall, [1 1 1 1 1])
    lg = legend(labels); 
end
Y.RM = RM; Y.LM = LM; Y.US = US; Y.DS = DS; Y.PL = PL; Y.NL = NL; Y.V = V; Y.C = C; Y.F = F;
Y.fRM = fRM; Y.fLM = fLM; Y.fUS = fUS; Y.fDS = fDS; Y.fPL = fPL; Y.fNL = fNL; Y.fV = fV; Y.fC = fC; Y.fF = fF;

% This list provides the cell IDs for members of each group. 
Y.tt_RM = X.neuronID(RM); [a, ~, ~] = fileparts(Y.tt_RM); Y.fd_RM = a;
Y.tt_LM = X.neuronID(LM); [a, ~, ~] = fileparts(Y.tt_LM); Y.fd_LM = a; 
Y.tt_US = X.neuronID(US); [a, ~, ~] = fileparts(Y.tt_US); Y.fd_US = a; 
Y.tt_DS = X.neuronID(DS); [a, ~, ~] = fileparts(Y.tt_DS); Y.fd_DS = a; 
Y.tt_PL = X.neuronID(PL); [a, ~, ~] = fileparts(Y.tt_PL); Y.fd_PL = a; 
Y.tt_NL = X.neuronID(NL); [a, ~, ~] = fileparts(Y.tt_NL); Y.fd_NL = a; 
Y.tt_V = X.neuronID(V); [a, ~, ~] = fileparts(Y.tt_V); Y.fd_V = a; 
Y.tt_C = X.neuronID(C); [a, ~, ~] = fileparts(Y.tt_C); Y.fd_C = a; 
Y.tt_F = X.neuronID(F); [a, ~, ~] = fileparts(Y.tt_F); Y.fd_F = a; 

Y.A = RM | US | PL | LM | DS | NL; 
























