function [Y] = processAHVregression_values(cfg_in, X)
% 10/2021. JJS.
% Inputs:   X  -  structre with fields X.  ...    (generated by findAHVslopesFromTuningCurves2.m)
%

%                       rsqAll:     [1×n double]     Rsq statistic for each neuron, fit with a single line
%                       pAll:       [1×n double]     p-values for each neuron, fit with a single line
%                       coeffsAll:  [n×2 double]     1st row = slope (Beta value); 2nd row = y-intercept. Single line fit
%                       rsqPos:     [1×n double]     Rsq for positive part of tuning curve (above zero deg/sec)
%                       pPos:       [1×n double]     p-values for positive part of tuning curve
%                       coeffsPos:  [n×2 double]     coeffs for positive part of tuning curve
%                       rsqNeg:     [1×n double]     Rsq for negative part of tuning curve
%                       pNeg:       [1×n double]     p-values for negative part of tuning curve
%                       coeffsNeg:  [n×1 double]     coeffs for negative part of tuning curve
% fd = FindFiles('*keys.m');
numCells = length(X. pAll);
cfg_def.Bonferroni = 0;
cfg_out = ProcessConfig2(cfg_def, cfg_in);

if cfg_out.Bonferroni == 0
    threshold = .05;
else
    threshold = .05/numCells;
end
Y.indexP = X.pPos < threshold & X.pNeg < threshold;  % index of cells with significant p-values for both components

%% Determine which cells are SYMMETRIC (and significant)
Y.indexSamePos = X.bPos>=0 &  X.bNeg>=0;
Y.indexSameNeg = X.bPos<=0 &  X.bNeg<=0;
Y.symmetric = Y.indexSamePos | Y.indexSameNeg;
Y.symmetricSig = Y.symmetric & Y.indexP;

%% Determine which cells are A-SYMMETRIC (and significant)
Y.index_Vshape = X.bPos>=0 &  X.bNeg<=0;    % Y.symmetric cells that have a 'V -shape' tuning cureve
Y.index_circumflex = X.bPos<=0 &  X.bNeg>=0;  % Y.symmetric cells that have a 'hat shaped' tuning curve (circumflex on the keyboard)
Y.Vshape_sig = Y.index_Vshape & Y.indexP;    % V -shaped cells that are significant
Y.circumflex_sig = Y.index_circumflex & Y.indexP;   % circumflex shaped cells that are significant
Y.sumVshape_sig = sum(Y.Vshape_sig); Y.perVshape_sig = Y.sumVshape_sig/numCells;
Y.sumcircumflex_sig = sum(Y.circumflex_sig); Y.percircumflex_sig = Y.sumcircumflex_sig/numCells;

Y.index_Vshape_sig = find(Y.Vshape_sig); 
Y.fd_Vshape = X.neuronID(Y.index_Vshape_sig); 
Y.index_circumflex_sig = find(Y.circumflex_sig);
Y.fd_circumflex = X.neuronID(Y.index_circumflex_sig);


end